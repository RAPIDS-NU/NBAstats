import json, os
import pandas as pd
import numpy as np
import NBAData as nba

pd.options.mode.chained_assignment = None

def clocktosec(clock):
    """
    Turns clock (HH:MM or MM:SS format) into time in units.
    """
     m, s = clock.split(':')
     return 60 * int(m) + int(s)

"""
this class will be used to collect the play by play data using the NBAData api to access the data from data.nba.com.
the data will be put into a dataframe that can be used with the dataframe of positional data. 
TODO:
- create constructor (params: date of the game, gameid)
- create fields for different parts of the data
- collect into dataframe to be used with position data. 
"""
class playbyplay_data(object):



    '''
    steps for cleaning data:
    - get data into dataframe
    - filter for 3pt shots
    - match up on time
    '''


    def __init__(self, gameID):
        """
        Stores ID, and notes that data has not been called yet.
        """
        self.ID = gameID
        self.g = 1


    def get(self):
        """
        Queries STATS server for game data.
        """
        headers = {'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0'}
        params = {'EndPeriod': 10, 'GameID': self.ID, 'StartPeriod': 1}
        r = requests.get("http://stats.nba.com/stats/playbyplayv2", params=params, headers=headers)
        self.data = r.json()
        self.g = 0 #Signifier. Separated out for debugging purposes.
        return self.data

    def unpack(self):
        """
        Unpacks json data received from STATS to extract the full play by play
        and put it in a convertible format.
        """
        """
        #1.0 Grabs data if not acquired already.
        """

        if self.g:
            self.get()
            self.g = 0

        """
        #1.1 Creates DataFrame.
        """
        plays = self.data['resultSets']
        plays = plays[0]
        cols = plays['headers']
        self.playbyplay = pd.DataFrame(plays['rowSet'], columns=cols)

        """
        #1.2 Sets columns to keep, and columns to reformat.
        """
        keepers = ['EVENTMSGTYPE', 'PERIOD', 'PCTIMESTRING', 'HOMEDESCRIPTION', \
                   'PLAYER1_ID', 'PLAYER1_NAME', 'PLAYER1_TEAM_ID', 'PLAYER1_TEAM_ABBREVIATION', \
                   'PLAYER2_ID', 'PLAYER2_NAME', 'PLAYER2_TEAM_ID', 'PLAYER2_TEAM_ABBREVIATION', \
                   'PLAYER3_ID', 'PLAYER3_NAME', 'PLAYER3_TEAM_ID', 'PLAYER3_TEAM_ABBREVIATION']
        strCols = ['PCTIMESTRING', 'HOMEDESCRIPTION', 'PLAYER1_ID', 'PLAYER1_NAME', \
                   'PLAYER1_TEAM_ID', 'PLAYER1_TEAM_ABBREVIATION', 'PLAYER2_ID', 'PLAYER2_NAME', \
                   'PLAYER2_TEAM_ID', 'PLAYER2_TEAM_ABBREVIATION', 'PLAYER3_ID', 'PLAYER3_NAME', \
                   'PLAYER3_TEAM_ID', 'PLAYER3_TEAM_ABBREVIATION']
        intCols = ['EVENTMSGTYPE', 'PERIOD']

        """
        #1.3 Sets frame to correct columns, and converts columns to correct datatypes.
        """
        self.playbyplay = self.playbyplay[keepers]
        for col in strCols:
            self.playbyplay[col] = self.playbyplay[col].astype(str)
        for col in intCols:
            self.playbyplay[col] = self.playbyplay[col].astype(int)

        """
        #2.0 The Class now identifies needed plays, adds column for game clock, and
             separates out the events that are shots and rebounds.
        """
        """
        #2.1 Identifies rows where shots occur, and the appropriate rebound for
             each shot.
        """
        shots = self.playbyplay.index[self.playbyplay['EVENTMSGTYPE'] == 2]

        """
        #2.2 Adds clock column and orders.
        """
        self.playbyplay['GameClock'] = self.playbyplay['PCTIMESTRING'].apply(clocker)
        self.playbyplay.sort_values(by=['PERIOD', 'GameClock'], ascending=[True, False], inplace=True)

        """
        #2.3 Separates the correct rows into new frames.
        """
        self.Shots = self.playbyplay.iloc[shots, :]
        self.Shots.reset_index(inplace=True, drop=True)
        return

    def run(self):
        self.unpack()

    if __name__ == '__main__':
        import time
        t = time.time()
        pbp = playbyplay('0021500293')
        pbp.run()
        print pbp.paired.info()
        print 'Runtime: ' + str(time.time() - t) + ' seconds'

playbyplay_data.run()